{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf600
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue-Bold;\f1\fnil\fcharset0 HelveticaNeue;\f2\fnil\fcharset0 Menlo-Regular;
\f3\fnil\fcharset0 LucidaGrande;\f4\fnil\fcharset0 HelveticaNeue-Italic;\f5\fnil\fcharset0 Menlo-Bold;
}
{\colortbl;\red255\green255\blue255;\red25\green25\blue25;\red255\green255\blue255;\red184\green14\blue61;
\red247\green238\blue241;\red38\green38\blue38;\red242\green242\blue242;\red247\green247\blue247;}
{\*\expandedcolortbl;;\cssrgb\c12941\c12941\c12941;\cssrgb\c100000\c100000\c100000;\cssrgb\c78039\c14510\c30588;
\cssrgb\c97647\c94902\c95686;\cssrgb\c20000\c20000\c20000;\cssrgb\c96078\c96078\c96078;\cssrgb\c97647\c97647\c97647;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid1\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{circle\}}{\leveltext\leveltemplateid2\'01\uc0\u9702 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat6\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid101\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{circle\}}{\leveltext\leveltemplateid102\'01\uc0\u9702 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{square\}}{\leveltext\leveltemplateid103\'01\uc0\u9642 ;}{\levelnumbers;}\fi-360\li2160\lin2160 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat11\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid201\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{circle\}}{\leveltext\leveltemplateid202\'01\uc0\u9702 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat14\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid301\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{circle\}}{\leveltext\leveltemplateid302\'01\uc0\u9702 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{square\}}{\leveltext\leveltemplateid303\'01\uc0\u9642 ;}{\levelnumbers;}\fi-360\li2160\lin2160 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat19\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid401\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{circle\}}{\leveltext\leveltemplateid402\'01\uc0\u9702 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listname ;}\listid5}
{\list\listtemplateid6\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat21\levelspace360\levelindent0{\*\levelmarker \{decimal\}.}{\leveltext\leveltemplateid501\'02\'00.;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{circle\}}{\leveltext\leveltemplateid502\'01\uc0\u9702 ;}{\levelnumbers;}\fi-360\li1440\lin1440 }{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{square\}}{\leveltext\leveltemplateid503\'01\uc0\u9642 ;}{\levelnumbers;}\fi-360\li2160\lin2160 }{\listname ;}\listid6}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}{\listoverride\listid6\listoverridecount0\ls6}}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl420\sa200\partightenfactor0

\f0\b\fs40 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Tasks\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls1\ilvl0
\f1\b0\fs28 \cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	1.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Create a\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 vector
\f1\fs28 \cf2 \cb3 \strokec2 \'a0with various values. Print it out using the ranged for. (For later exercises, it may simplify your life if there are an even number of elements.)\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	2.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Copy this into a\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 list
\f1\fs28 \cf2 \cb3 \strokec2 , using the list constructor that takes a half-open range, provided by\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 begin()
\f1\fs28 \cf2 \cb3 \strokec2 \'a0and\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 end()
\f1\fs28 \cf2 \cb3 \strokec2 . Print this list out.\cb1 \
\ls1\ilvl0\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	3.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Sort the original vector, then print both it and the list out.\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls1\ilvl1\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Note that sorting the list cannot be done the same way. We will discuss why further down and how to work around that.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls1\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	4.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Write a loop to print every\'a0
\f4\i other
\f1\i0 \'a0element of the vector, starting with the first element. The ranged for won't work for this, instead use an "index-based" for-loop.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls1\ilvl0
\f4\i \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	5.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Attempt
\f1\i0 \'a0to do the same with the linked list.\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls1\ilvl1\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 It doesn't compile.\cb1 \
\ls1\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Why? No op[] for list!\cb1 \
\ls1\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Why didn't they provide op[] for list? Easy to write, right? (In fact you've done it.) They omitted it just so we wouldn't try to use it in a loop like this. (How did you write it? Each call to op[] required walking from the front of the list. To loop over N items this way would take approximately N
\fs21 2
\fs28 \'a0/ 2 steps. Ouch!)\cb1 \
\pard\pardeftab720\sl420\sa200\partightenfactor0

\f0\b\fs40 \cf2 \cb3 Iterators\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls2\ilvl0
\f1\b0\fs28 \cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	6.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Use iterators to redo task 4, i.e display every\'a0
\f4\i other
\f1\i0 \'a0element of the vector.\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls2\ilvl1\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Remember how to declare the\'a0
\f4\i type
\f1\i0 \'a0of an iterator.\cb1 \
\ls2\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Note that the iterators we are using here, i.e. the iterators for a list, support: copy constructor, !=, ++, --, and dereference.\cb1 \
\ls2\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Also iterators for vectors support adding on arbitrary integer values, just as we could with pointer arithmetic. This sort of iterator is known as a\'a0
\f0\b random access iterator
\f1\b0 . For this task, use this random access ability of vector's iterators.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls2\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	7.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Repeat the previous task for the list.\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls2\ilvl1\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 In the previous task, you bumped the iterator by 2, but that won't work with the list iterator. List iterators do not support random access. Same reason that lists don't support the index operator.\cb1 \
\ls2\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 So figure a work around in order to repeat the previous task for the list.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls2\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	8.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Also, we have now seen that there is more than one kind of iterator.\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls2\ilvl1\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Lists have\'a0
\f4\i bidirectional
\f1\i0 \'a0iterators which support moving back and forth, but\'a0
\f4\i only
\f1\i0 \'a0by using the increment and decrement operators. Vectors have iterators that do all of that but also support an addition operator that takes as a second argument an integer, so that you can do the equivalent of pointer arithmetic with vector iterators. Again, these are known as random access iterators.\cb1 \
\ls2\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 As you know, most sort algorithms require random access. Because of that, we cannot use the algorithm\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 sort
\f1\fs28 \cf2 \cb3 \strokec2 \'a0with the iterators for a list. Of course, lists can be sorted (hopefully you sorted lists in your data structures course) and the list class has its own sort\'a0
\f4\i method
\f1\i0 . The method does not take any arguments, its purpose being to sort the entire list.\cb1 \
\ls2\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Sort your list with the list class's sort method. And of course show that it worked.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls2\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	9.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Write a function that is passed in a list of ints and prints the list using iterators.\cb1 \uc0\u8232 \cb3 [Naturally, it should be passed a constant reference to the list.]\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls2\ilvl1\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 First try using\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 list<int>::iterator
\f1\fs28 \cf2 \cb3 \strokec2 \'a0as before and observe that you get a compilation error.\cb1 \
\ls2\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Try again using\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 list<int>::const_iterator
\f1\fs28 \cf2 \cb3 \strokec2 .\
\pard\tx1660\tx2160\pardeftab720\li2160\fi-2160\sl320\partightenfactor0
\ls2\ilvl2\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9642 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 It works!\cb1 \
\ls2\ilvl2\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9642 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 But what a pain!\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls2\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	10.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Repeat the previous task of printing the list, but this time instead of using iterators, use a ranged for.\cb1 \uc0\u8232 \cb3 Happily, this works just as before. And no complication with const.\cb1 \
\pard\pardeftab720\sl420\sa200\partightenfactor0

\f0\b\fs40 \cf2 \cb3 Auto\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls3\ilvl0
\f1\b0\fs28 \cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	11.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 So, using ranged-for is great where we can get away with it. But when we can't, it can be annoying having to specify those messy types.\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls3\ilvl1\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 In comes auto!!!\cb1 \
\ls3\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Let's write a function that will print every other item in the list. Instead of worrying about how to specify the type for the iterator, just use the keyword\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 auto
\f1\fs28 \cf2 \cb3 \strokec2 . The code is easier to write and actually easier to read, while still being statically typed. Yes, it is statically typed, but the compiler is doing the work using\'a0
\f4\i type inference
\f1\i0 \cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls3\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	12.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Write a function to find an item in the list, returning an iterator for where it is.\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls3\ilvl1\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 The function will take a list, again passed by const reference, and an int to search for.\cb1 \
\ls3\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Do not use auto.\cb1 \
\ls3\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 What did you have to use for the return type?\cb1 \
\ls3\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 What should / did you return when the search failed?\cb1 \
\ls3\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Be sure to test the function with an item that is there and an item that is not there.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls3\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	13.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Ok, modify the for loop to use auto. That works, great.\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls3\ilvl1\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 What about the return type. That still has the ugly\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 const_iterator
\f1\fs28 \cf2 \cb3 \strokec2 . Try to use an\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 auto
\f1\fs28 \cf2 \cb3 \strokec2 \'a0there. If your compiler supports not just c++11, but also c++14, then it will work.\cb1 \
\pard\pardeftab720\sl420\sa200\partightenfactor0

\f0\b\fs40 \cf2 \cb3 Generic Algorithms\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls4\ilvl0
\f1\b0\fs28 \cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	14.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Use the algorithm\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 find
\f1\fs28 \cf2 \cb3 \strokec2 \'a0to do the same as the previous step.\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls4\ilvl1\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Note the need for the include <algorithm> (actually, we already included it to use sort).\cb1 \
\ls4\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Remember that the generic\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 find
\f1\fs28 \cf2 \cb3 \strokec2 \'a0is\'a0
\f4\i not
\f1\i0 \'a0passed a collection, instead it is passed a \'93half-open range\'94.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls4\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	15.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Use the algorithm\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 find_if
\f1\fs28 \cf2 \cb3 \strokec2 \'a0to locate the first even number in the vector and in the list and print them out.\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls4\ilvl1\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Note that you first have to define a\'a0
\f4\i function
\f1\i0 \'a0that takes an\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 int
\f1\fs28 \cf2 \cb3 \strokec2 \'a0and returns a\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 bool
\f1\fs28 \cf2 \cb3 \strokec2 \'a0indicating whether the integer was even or not.\cb1 \
\ls4\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 When you call\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 find_if
\f1\fs28 \cf2 \cb3 \strokec2 , you will pass in the usual half-open range defining where to search, followed by the function. How do you pass a function? Just pass its name. No, don't imagine that the\'a0
\f4\i code
\f1\i0 \'a0for the function is being passed in, the name just specifies what function we are calling.\cb1 \
\ls4\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Of course, the vector / list that you are searching may not have any even numbers, so the code that checks the return value of find_if must be prepared for such a condition.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls4\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	16.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Let's use a\'a0
\f0\b functor
\f1\b0 \'a0for the problem of defining the function to decide if an int is even.\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls4\ilvl1\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 A functor is an instance of a class that has implemented the "parenthesis operator", aka the\'a0
\f4\i function call operator
\f1\i0 .\cb1 \
\ls4\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 So, first define a class, call it whatever you want.\cb1 \
\ls4\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Next, define a method, i.e. a member function, for the function call operator. What will its name be? Naturally the word\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 operator
\f1\fs28 \cf2 \cb3 \strokec2 \'a0followed by the characters used for the operator. What are they in this a case? Yes, a pair of parentheses. So, despite how odd it may look, the name is\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 operator()
\f1\fs28 \cf2 \cb3 \strokec2 .\cb1 \
\ls4\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 The parameters? Whatever parameters your function took for deciding if an int was even. I would guess that that was the int itself.\cb1 \
\ls4\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Yes, you\'a0
\f4\i can
\f1\i0 \'a0define versions of the operator that take whatever and however many parameters you like. Not only that but the function call operator can be overloaded within your class. We just don't need any of that now.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls4\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	17.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Let's use a\'a0
\f0\b lambda expression
\f1\b0 \'a0for the problem of finding the first even number.\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls4\ilvl1\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 A lambda expression is an "unamed function". It has a bit of an odd syntax. The simplest example woule be:\cb1 \uc0\u8232 
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 [] \{ cout << "Hello Lambda!"; \}
\f1\fs28 \cf2 \cb1 \strokec2 \
\ls4\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 You could actually run that. Just put it on a line in main. And put a pair of parentheses after it, because after all if that's a function, and we still have to\'a0
\f4\i call
\f1\i0 \'a0it. So main could look like:
\f2\fs26 \cf6 \cb7 \strokec6 \
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl360\partightenfactor0
\ls4\ilvl1\cf6 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec6 int main() \{\
\ls4\ilvl1\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec6      
\f5\b [] \{ cout << "Hello Lambda!"; \}();
\f2\b0 \
\ls4\ilvl1\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec6 \}\uc0\u8232 
\f1\fs35 \cf2 \cb8 \strokec2 \uc0\u8232 
\fs28 \cb1 \
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls4\ilvl1\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 So, what have we learned? The syntax for defining a lambda expression requires a pair of square brackets. Inside the square brackets there may be specified a list of variables that would be "captured". That does not affect us right now, so I will not explain any more about it.\cb1 \
\ls4\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 But what we haven't seen that we do need is how to provide a parameter list. That's because the the function we wroted didn't need one. And the point of lamda expressions is to minimize what you need to write. So if you don't need any parameters, then you dodn't even need a parameter list! If you do need parameters, then the parameter list would go right after the square brackets. I'll show you the use of a lambda expression taking two ints and printing the results. Try putting the following line in your program. It should print 9.
\f2\fs26 \cf6 \cb7 \strokec6 \
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl360\partightenfactor0
\ls4\ilvl1\cf6 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec6     [] 
\f5\b (int a, int b)
\f2\b0  \{ cout << a + b << endl; \} (4, 5);\uc0\u8232 
\f1\fs35 \cf2 \cb8 \strokec2 \uc0\u8232 
\fs28 \cb1 \
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls4\ilvl1\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 What if we want to return the sum instead of printing it?
\f2\fs26 \cf6 \cb7 \strokec6 \
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl360\partightenfactor0
\ls4\ilvl1\cf6 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec6     int result = [] (int a, int b) \{ return a + b; \} (4, 5);\
\ls4\ilvl1\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec6     cout << "the result is: " << result << endl;\uc0\u8232 
\f1\fs35 \cf2 \cb8 \strokec2 \uc0\u8232 
\fs28 \cb1 \
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls4\ilvl1\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Note that something else seems to be missing? The return type was never stated! Again, C++ is trying hard to learn how to reduce how much you have to type. It is clear to the compiler that this lambda expression is returning an int so it doesn't require that you say so.\cb1 \
\ls4\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 If you did want to say what the return type for that lambda expression was supposed to be, then the above code would instead look like:
\f2\fs26 \cf6 \cb7 \strokec6 \
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl360\partightenfactor0
\ls4\ilvl1\cf6 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec6     int result2 = [] (int a, int b) 
\f5\b -> int
\f2\b0  \{ return a + b; \} (4, 5);\
\ls4\ilvl1\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	\uc0\u9702 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec6     cout << "the result is: " << result2 << endl;\uc0\u8232 
\f1\fs35 \cf2 \cb8 \strokec2 \
\pard\tx1660\tx2160\pardeftab720\li2160\fi-2160\sl320\partightenfactor0
\ls4\ilvl2
\fs28 \cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9642 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Yes, the return type shows up just before the body, after the optional parameter list. With the arrow which has nothing to do with a pointer. Wierd, but you don't usually need to mention the return type. Lambda expressions are usually short and clear.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls4\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	18.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Define a local array, the same size as the list and the vector.\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls4\ilvl1\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 You can do this with the line:\cb1 \uc0\u8232 
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 int arr[8]; // if there are eight items in the vector
\f1\fs28 \cf2 \cb3 \strokec2 \'a0and the list.\cb1 \
\ls4\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Use the\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 copy
\f1\fs28 \cf2 \cb3 \strokec2 \'a0algorithm to fill it either from the list or the vector.\
\pard\tx1660\tx2160\pardeftab720\li2160\fi-2160\sl320\partightenfactor0
\ls4\ilvl2\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9642 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Copy is passed the half-open range that it is copying\'a0
\f4\i from
\f1\i0 \'a0and the location of the first item it is copying\'a0
\f4\i to
\f1\i0 .\cb1 \
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls4\ilvl1\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Again, print its contents.\cb1 \
\ls4\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Use find on the array to do the same tests we did before.\cb1 \uc0\u8232 \cb3 What do we have to pass in to specify the half-open range?\cb1 \
\pard\pardeftab720\sl420\sa200\partightenfactor0

\f0\b\fs40 \cf2 \cb3 Templated functions\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls5\ilvl0
\f1\b0\fs28 \cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	19.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Implement your own version of the find algorithm (call it ourFind) for lists of ints. This will be a\'a0
\f4\i function
\f1\i0 ,\'a0
\f0\b not
\f1\b0 \'a0a function\'a0
\f4\i template
\f1\i0 .\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls5\ilvl1\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Put a print statement in your function so that we know it is yours\cb1 \
\ls5\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 show that it works, using the same tests you used with the library version.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls5\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	20.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Rewrite ourFind as a function template. You do not have to comment out the function you wrote in the previous task.\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls5\ilvl1\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 In the template, change the print line to say you are in the template\cb1 \
\ls5\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Test your template using the vector.\cb1 \
\ls5\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Run your test again on the list. Notice that C++ used your function, not the template.\cb1 \uc0\u8232 \cb3 That's a good thing!\cb1 \
\pard\pardeftab720\sl420\sa200\partightenfactor0

\f0\b\fs40 \cf2 \cb3 Collections\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls6\ilvl0
\f1\b0\fs28 \cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	21.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Read a file, listing all of items, but list each distinct item only once. A text file is attached to this recitation for this purpose.\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls6\ilvl1\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Solve this using a vector of strings to track what you have seen.\cb1 \
\ls6\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 For each word that you read from the file check if it is in the vector and if it isn't then add it to the vector.\cb1 \
\ls6\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 After filling the vector, display its size and contents.\cb1 \
\ls6\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Running this on the attached file, you will likely notice your program hesitate a moment while it fills the vector.\cb1 \
\ls6\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Incidentally, when I ran my solution, I found 2,278 distinct words.\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls6\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	22.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Repeat the previous task but instead of using a\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 vector
\f1\fs28 \cf2 \cb3 \strokec2 \'a0to hold the strings, use a\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 set
\f1\fs28 \cf2 \cb3 \strokec2 \'a0to do so.\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls6\ilvl1\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 You will have to include the set header file, i.e.\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 #include <set>
\f1\fs28 \cf2 \cb1 \strokec2 \
\ls6\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 You define a set the same way as you define a vector, simple type set and then place the kind of things the set should hold in angle brackets.\cb1 \
\ls6\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 You\'a0
\f4\i could
\f1\i0 \'a0test if an item is in a set, use the set\'a0\ul method\ulnone \'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 find
\f1\fs28 \cf2 \cb3 \strokec2 . If the item is not found, find will return the same value as set's end() method. (Note this is not the generic find algorithm. Why not?)\cb1 \
\ls6\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 However, to add an item to a set, just use the\'a0\ul set method\ulnone \'a0called\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 insert
\f1\fs28 \cf2 \cb3 \strokec2 . If the item is already in the set, then nothing will change, so you don't actually need to first test if it is there.\cb1 \
\ls6\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 You will see that this version finishes much faster.\'a0
\f4\i And
\f1\i0 \'a0the elements will be displayed in sorted order without your having to write any code to do handle the sorting! (How do you think that was done?)\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\sl320\partightenfactor0
\ls6\ilvl0\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	23.	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Finally, we will repeat a problem from early in the semester where we tracked word positions from a document. Remember how we created a struct to hold the token and a vector of positions, where a position indicated what token\'a0
\f4\i number
\f1\i0 \'a0it is, not the character position (which would be more work for you). Then maintained a vector of these struct instances? This time we will use a\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 map
\f1\fs28 \cf2 \cb3 \strokec2 , much like a dictionary in Python, to map from the tokens to their vectors. The goal is to print out each word in the document, one per line, together with the token positions for that word.\
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls6\ilvl1\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 First we need to define our map variable. (Of course, we have to have included the map header file, just as we did with the set.)\
\pard\tx1660\tx2160\pardeftab720\li2160\fi-2160\sl320\partightenfactor0
\ls6\ilvl2\cf2 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9642 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 The map requires\'a0
\f4\i two
\f1\i0 \'a0types, not just one. We have to say what we are mapping from, here a string, and what we are mapping to, here a vector of ints. So we could define a variable wordMap, as follows:\cb1 \uc0\u8232 
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 map<string, vector<int>> wordMap;
\f1\fs28 \cf2 \cb1 \strokec2 \
\pard\tx940\tx1440\pardeftab720\li1440\fi-1440\sl320\partightenfactor0
\ls6\ilvl1\cf2 \cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 We can access each element of the map, using the square bracket operator. wordMap["fred"] would return the value, a vector of ints, for fred's entry in the map. And if fred hasn't been entered yet, it automatically creates an entry with a value the is "default initialized". In the case of our map, since the value is a vector, it will be initialized to an empty vector.\cb1 \
\ls6\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 All we need to do is push_back onto that vector the new position. The line:\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 wordMap["fred"].push_back(17)
\f1\fs28 \cf2 \cb1 \strokec2 \uc0\u8232 \cb3 would add the position 17 to fred's vector. And if fred wasn't there before, it will now be there with a vector holding just the single value 17. Almost like magic!\cb1 \
\ls6\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Finally we need to be able to loop over the map. Using the ranged for, it is very easy. Each item in the map is something called a\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 pair
\f1\fs28 \cf2 \cb3 \strokec2 . A pair has two fields\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 first
\f1\fs28 \cf2 \cb3 \strokec2 \'a0and\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 second
\f1\fs28 \cf2 \cb3 \strokec2 . In a\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 map
\f1\fs28 \cf2 \cb3 \strokec2 , the field\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 first
\f1\fs28 \cf2 \cb3 \strokec2 \'a0for each entry is the "key" (the word) and the field\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 second
\f1\fs28 \cf2 \cb3 \strokec2 \'a0is the "value" (the vector of positions). To keep your life simple, you may use the keyword\'a0
\f2\fs25\fsmilli12600 \cf4 \cb5 \strokec4 auto
\f1\fs28 \cf2 \cb3 \strokec2 \'a0to specify the type for the ranged-for.\cb1 \
\ls6\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 For each item in the vector, first print out the wordand then print out all of the positions. It would look best to do this all on one line for each word.\cb1 \
\ls6\ilvl1\cb3 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	
\f3 \uc0\u9702 
\f1 	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Again, notice how quickly this runs and that the words appear in sorted order. And it was a lot easier to write than what we did in class!\cb1 \
}